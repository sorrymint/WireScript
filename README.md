# WireScript

A FOSS web Programmatically Defined Home wire diagram and simulation tool.
The user will “code” in a Domain-Specific Language (DSL) called WireScript.
The program will then parse, render and simulate the users wiring diagram.
The tech stack can be broken down into three main components:

1. Frontend (Svelte app),
2. Parser (for the DSL),
3. Backend logic (for simulation and Validation).

## Frontend (SvelteKit)

### Editor

An embedded code editor for the WireScript language

[//]: # (could be built using the Monaco Editor)

### Diagramming

For rendering the visual diagrams, a flexible graphics library

[//]: # (Library ideas &#40;AI&#41;)

[//]: # (Svelte Flow: A Svelte-native library for creating node-based editors and diagrams. It offers)

[//]: # (features like a minimap, viewport controls, and customizable nodes and edges, making it a)

[//]: # (strong choice.)

[//]: # (D3.js: A more complex but powerful option for data-driven documents. It gives you maximum)

[//]: # (control over the visualization but requires more manual coding.)

[//]: # (JointJS: Another professional diagramming library that provides advanced features like)

[//]: # (AI-powered visual applications.)

## Parser (DSL Processing)

This is the core logic that translates the human-readable WireScript code into a structured data
format for the application.

[//]: # (Library ideas &#40;AI&#41;:)

[//]: # (- ANTLR &#40;ANother Tool for Language Recognition&#41;)

[//]: # (- Chevrotain can generate a parser from a grammar definition. Chevrotain is a)

[//]: # (  JavaScript-based option optimized for the V8 engine, making it a good fit for a web app.)

## Backend Logic (Simulation and Validation)

Uses AST generated by the parser to perform checks and run simulations.

[//]: # (Library ideas &#40;AI&#41;:)

[//]: # (Engine: A custom-built engine would traverse the AST and apply electrical rules. For example, it)

[//]: # (could check if a circuit's total connected load exceeds the breaker's amperage.)

[//]: # (How to start: A step-by-step guide)

## Road Map

1. Define the DSL grammar. Before writing any parsing code, we will want formal grammar
   that defines the rules of the WireScript language. The grammar file would define what
   keywords and symbols are valid, and how they can be combined.
2. Implement the parser. Choose a parsing library and follow its documentation to create a
   parser based on your grammar. The output of the parser should be a predictable JSON
   or JavaScript object that represents the electrical system described in the WireScript file.
   I would like to use Typescript Classes for each node type (Switch, Outlet, Distribution
   panel)
3. Create the Svelte UI.
    - An editor component to let users write WireScript.
    - A diagramming component to render the output. Panels for displaying validation
      errors, simulation results, and component properties.
    - UI “ribbon” for file, edit, etc.
4. Integrate the parser and diagrammer In a Svelte store, hold the current WireScript code
   and the parsed AST. Use a Svelte Flow component to display the diagram by
   subscribing to the AST's changes.
5. Build the simulation and validation engine. Create a JavaScript module that:
    - Takes the AST as input.
    - Performs validation checks (e.g., circuit load calculation, wire gauge sizing).
    - Returns an object containing results and any errors.
6. Visualize validation results. Enhance Svelte components to display validation errors. For
   example, if a circuit is overloaded, the corresponding diagram element could be
   highlighted in red, and the error details displayed in a panel.
7. Implement simulation features. Extend the engine to simulate how the system behaves.
   For example, toggle a virtual switch in the diagram to simulate turning on or off a set of
   lights, and update the simulation results accordingly.